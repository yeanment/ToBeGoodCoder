# 基本语言特性
## 生成器和迭代器
python生成器是一个返回可以迭代对象的函数,可以被用作控制循环的迭代行为。生成器类似于返回值为数组的一个函数,这个函数可以接受参数,可以被调用,一般的函数会返回包括所有数值的数组,生成器一次只能返回一个值,这样消耗的内存将会大大减小。

## is和==的区别
+ is用来判断两个变量引用的对象是否为同一个
+ ==用于判断引用对象的值是否相等
+ id()函数查看引用对象的地址。

## 方法解析顺序
Python的方法解析顺序优先级从高到低为:实例本身类继承类(继承关系越近,越先定义,优先级越高)

## dict和list的区别
+ dict查找速度快，占用的内存较大，dict不能用来存储有序集合，用{}表示。dict是通过hash表实现的,dict为一个数组,数组的索引键是通过hash函数处理后得到的,hash函数的目的是使键值均匀的分布在数组中。
+ list查找速度慢，占用内存较小，用[]表示。

## 深拷贝，浅拷贝
深复制和浅复制最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。
+ 浅复制：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。
+ 深复制：在计算机中开辟了一块新的内存地址用于存放复制的对象。

## 多进程
+ os.fork()
+ 使用multiprocessing模块：创建Process的实例，传入任务执行函数作为参数；派生Process的子类，重写run方法
+ 使用进程池Pool

## 各种锁

### 全局解释器锁（GIL）
> 每个CPU在同一时间只能执行一个线程，那么其他的线程就必须等待该线程的全局解释器，使用权消失后才能使用全局解释器，即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）。GIL的设计简化了CPython的实现，使的对象模型包括关键的内建类型，如：字典等，都是隐含的，可以并发访问的，锁住全局解释器使得比较容易的实现对多线程的支持，但也损失了多处理器主机的并行计算能力。
>
> 全局解释器锁避免了大量的加锁解锁的好处，使数据更加安全，解决多线程间的数据完整性和状态同步。但同时，它使多核处理器退化成单核处理器，只能并发不能并行。
>
> GIL一般适用于多线程情况下必须存在资源的竞争，保证在解释器级别的线程唯一使用共享资源（cpu）。

### 同步锁
> 同一时刻的一个进程下的一个线程只能使用一个cpu，要确保这个线程下的程序在一段时间内被cpu执行，那么就要用到同步锁。因为有可能当一个线程在使用cpu时，该线程下的程序可能会遇到io操作，那么cpu就会切到别的线程上去，这样就有可能会影响到该程序结果的完整性。只需要在对公共数据的操作前后加上上锁和释放锁的操作即可使用同步锁。同步锁保证解释器级别下的自己编写的程序唯一使用共享资源产生了同步锁。

### 死锁
> 死锁指两个或两个以上的线程或进程在执行程序的过程中，因争夺资源或者程序推进顺序不当而相互等待的一个现象。死锁产生的必要条件：互斥条件、请求和保持条件、不剥夺条件、环路等待条件。处理死锁的基本方法：预防死锁、避免死锁（银行家算法）、检测死锁（资源分配）、解除死锁（剥夺资源、撤销进程）。

### 递归锁
> 在Python中为了支持同一个线程中多次请求同一资源，Python提供了可重入锁。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。递归锁分为可递归锁与非递归锁。

### 乐观锁
> 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

### 悲观锁
> 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

### 常用的加锁方式
> 互斥锁、可重入锁、迭代死锁、互相调用死锁、自旋锁。


# PyTorch 相关
## pytorch中cuda()作用
+ cuda()将操作对象放在GPU内存中，加了cuda()的Tensor放在GPU内存中
+ 没加cuda()的Tensor放在CPU内存中

