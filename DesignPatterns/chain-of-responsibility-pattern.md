# Chain of Responsibility

## Motivation
In writing an application of any kind, it often happens that the event generated by one object needs to be handled by another one. And, to make our work even harder, we also happen to be denied access to the object which needs to handle the event. In this case there are two possibilities: there is the beginner/lazy approach of making everything public, creating reference to every object and continuing from there and then there is the expert approach of using the Chain of Responsibility.

The Chain of Responsibility design pattern allows an object to send a command without knowing what object will receive and handle it. The request is sent from one object to another making them parts of a chain and each object in this chain can handle the command, pass it on or do both. The most usual example of a machine using the Chain of Responsibility is the vending machine coin slot: rather than having a slot for each type of coin, the machine has only one slot for all of them. The dropped coin is routed to the appropriate storage place that is determined by the receiver of the command.

## Intent
- It avoids attaching the sender of a request to its receiver, giving this way other objects the possibility of handling the request too.
- The objects become parts of a chain and the request is sent from one object to another across the chain until one of the objects will handle it.

## Implementation
- Handler defines an interface for handling requests
- RequestHandler handles the requests it is responsible for. If it can handle the request it does so, otherwise it sends the request to its successor
- Client sends commands to the first object in the chain that may handle the command

Here is how sending a request works in the application using the Chain of Responsibility: the Client in need of a request to be handled sends it to the chain of handlers, which are classes that extend the Handler class. Each of the handlers in the chain takes its turn at trying to handle the request it receives from the client. If ConcreteHandler_i can handle it, then the request is handled, if not it is sent to the handler ConcreteHandler_i+1, the next one in the chain.

```C++
class Request {    
private:
    int m_value;
    string m_description;

public:
    Request(string description, int value)
    {
        m_description = description;
        m_value = value;
    }

    int getValue()
    {
        return m_value;
    }

    string getDescription()
    {
        return m_description;
    }          
}

virtual class Handler
{
protected:
    Handler m_successor;
public:
    void setSuccessor(Handler successor)
    {
        m_successor = successor;
    }

    virtual void handleRequest(Request request);
}

class ConcreteHandlerOne::Handler
{
public:
    void handleRequest(Request request)
    {
        if (request.getValue() < 0)
        {           //if request is eligible handle it
            cout << "Negative values are handled by ConcreteHandlerOne:";
            cout << "\tConcreteHandlerOne.HandleRequest : " << request.getDescription() << request.getValue());
        }
        else
        {
            super.handleRequest(request);
        }
    }
 }


class ConcreteHandlerTwo::Handler
{
public:
    void handleRequest(Request request)
    {
        if (request.getValue() >= 0)
        {           //if request is eligible handle it
            cout << "Zero values are handled by ConcreteHandlerTwo:" << endl>>;
            cout <<"\tConcreteHandlerTwo.HandleRequest : " << request.getDescription() << request.getValue()) << endl;
        }
        else
        {
            super.handleRequest(request);
        }
    }
}

class ConcreteHandlerThree::Handler
{
public:
    void handleRequest(Request request)
    {
        if (request.getValue() >= 0)
        {           //if request is eligible handle it
            cout << "Zero values are handled by ConcreteHandlerThree:" << endl>>;
            cout <<"\tConcreteHandlerThree.HandleRequest : " << request.getDescription() << request.getValue()) << endl;
        }
        else
        {
            super.handleRequest(request);
        }
    }
}


class Main 
{
public:
    static void main(string[] args) 
    {
        // Setup Chain of Responsibility
        Handler h1 = new ConcreteHandlerOne();
        Handler h2 = new ConcreteHandlerTwo();
        Handler h3 = new ConcreteHandlerThree();
        h1.setSuccessor(h2);
        h2.setSuccessor(h3);

        // Send requests to the chain
        h1.handleRequest(new Request("Negative Value ", -1));
        h1.handleRequest(new Request("Negative Value ",  0));
        h1.handleRequest(new Request("Negative Value ",  1));
        h1.handleRequest(new Request("Negative Value ",  2));
        h1.handleRequest(new Request("Negative Value ", -5));        
    }
}

```

## Applicability & Examples
Here are a few situations when using the Chain of Responsibility is more effective:
- More than one object can handle a command
- The handler is not known in advance
- The handler should be determined automatically
- It’s wished that the request is addressed to a group of objects without explicitly specifying its receiver
- The group of objects that may handle the command must be specified in a dynamic way

### Example 1: Designing software to approve the purchasing requests.
In this case, the values of purchase are divided into categories, each having its own approval authority. The approval authority for a given value could change at any time and the system should be flexible enough to handle the situation.

The Client in the example above is the system in need of the answer to the approval. It sends a request about it to an purchase approval authority. Depending on the value of the purchase, this authority may approve the request or forward it to the next authority in the chain.

For example let’s say a request is placed for the purchase of a new keyboard for an office. The value of the purchase is not that big, so the request is sent from the head of the office to the head of the department and then to the materials department where it stops, being handled locally. But if equipment for the whole department is needed then the request goes form the head of the department, to materials department, to the purchase office and even to the manager if the value is too big.

## Specific problems and implementation
### Representing requests
In real life each handler represents a system. And each system can handle specific requests or requests common to more handlers. We should take this issue in consideration when we implement this pattern. In the classical samples of the CoR found on the net you can see that the request is generally represented by an integer. Of course in real life we can not use primary data types as a request.

A clever design should be a flexible one. The best solution here is to create an interface a super class Request (or and interface) where to the default behavior. Then if we need to add a new handler and a specific request all we need is to extend the Request base class.

Of course this is not the only approach. Let’s consider the shipping system example. Each request will have to contain a large amount of data. Creating request examples for this might be difficult. We can take some xml objects containing the data, generated during the application flow (let’s assume we already have the code implemented for that) and pass them to each handler.

Or since the data was already saved in the database (let’s assume that also) we can pass only the id’s of the involved objects and then each handler will take the data required from db.

### Unhandled requests
Unfortunately, the Chain doesn't guarantee that every command is handled, which makes the problem worse, since unhandled commands propagate through the full length of the chain, slowing down the application. One way to solve this is by checking if, at the end of the chain, the request has been handled at least once, otherwise we will have to implement handlers for all the possible requests that may appear.

### Broken Chain
Sometimes we could forget to include in the implementation of the handleRequest method the call to the successor, causing a break in the chain. The request isn’t sent forward from the broken link and so it ends up unhandled. A variation of the pattern can be made to send the request to all the handlers by removing the condition from the handler and always calling the successor.

### Avoiding spam requests
For example, an improvement that we could find useful is avoiding sending spam commands. This way, the concrete extension of the HandleRequest function will look like this:
```C++
void HandleRequest(int request) 
{
	if(isSpam(request))   
	{ // if the request is spam take spam-related actions
		...
	}
	else 
	{ // request is not spam.
		super.HandleRequest(request); // Pass message to next filter in the chain.
	}
}
```
### Use on existing code
The last, but not least problem that the Chain of Responsibility creates to a programmer is the fact that it is impossible to introduce the pattern into the existing classes without modifying the source code and, even in the case where the pattern is already included in the code, if new operations need to be added to the Handler, it is impossible to do that without modifying the source code. So the basic idea is to decide from the start on whether to use the pattern or not and if we do, what methods we need.
